# [repr (u8)] # [derive (Copy , Clone , Debug , Eq , PartialEq , Ord , PartialOrd)] # [cfg_attr (feature = "defmt" , derive (defmt :: Format))] pub enum Encie0 { # [doc = "Interrupt notification of Memory 0 non-correctable error events is disabled."] DISABLE = 0x0 , # [doc = "Interrupt notification of Memory 0 non-correctable error events is enabled."] ENABLE = 0x01 , } impl Encie0 { # [inline (always)] pub const fn from_bits (val : u8) -> Encie0 { unsafe { core :: mem :: transmute (val & 0x01) } } # [inline (always)] pub const fn to_bits (self) -> u8 { unsafe { core :: mem :: transmute (self) } } } impl From < u8 > for Encie0 { # [inline (always)] fn from (val : u8) -> Encie0 { Encie0 :: from_bits (val) } } impl From < Encie0 > for u8 { # [inline (always)] fn from (val : Encie0) -> u8 { Encie0 :: to_bits (val) } } # [repr (u8)] # [derive (Copy , Clone , Debug , Eq , PartialEq , Ord , PartialOrd)] # [cfg_attr (feature = "defmt" , derive (defmt :: Format))] pub enum Encie1 { # [doc = "Interrupt notification of Memory 1 non-correctable error events is disabled."] DISABLE = 0x0 , # [doc = "Interrupt notification of Memory 1 non-correctable error events is enabled."] ENABLE = 0x01 , } impl Encie1 { # [inline (always)] pub const fn from_bits (val : u8) -> Encie1 { unsafe { core :: mem :: transmute (val & 0x01) } } # [inline (always)] pub const fn to_bits (self) -> u8 { unsafe { core :: mem :: transmute (self) } } } impl From < u8 > for Encie1 { # [inline (always)] fn from (val : u8) -> Encie1 { Encie1 :: from_bits (val) } } impl From < Encie1 > for u8 { # [inline (always)] fn from (val : Encie1) -> u8 { Encie1 :: to_bits (val) } } # [repr (u8)] # [derive (Copy , Clone , Debug , Eq , PartialEq , Ord , PartialOrd)] # [cfg_attr (feature = "defmt" , derive (defmt :: Format))] pub enum Escie0 { # [doc = "Interrupt notification of Memory 0 single-bit correction events is disabled."] DISABLE = 0x0 , # [doc = "Interrupt notification of Memory 0 single-bit correction events is enabled."] ENABLE = 0x01 , } impl Escie0 { # [inline (always)] pub const fn from_bits (val : u8) -> Escie0 { unsafe { core :: mem :: transmute (val & 0x01) } } # [inline (always)] pub const fn to_bits (self) -> u8 { unsafe { core :: mem :: transmute (self) } } } impl From < u8 > for Escie0 { # [inline (always)] fn from (val : u8) -> Escie0 { Escie0 :: from_bits (val) } } impl From < Escie0 > for u8 { # [inline (always)] fn from (val : Escie0) -> u8 { Escie0 :: to_bits (val) } } # [repr (u8)] # [derive (Copy , Clone , Debug , Eq , PartialEq , Ord , PartialOrd)] # [cfg_attr (feature = "defmt" , derive (defmt :: Format))] pub enum Escie1 { # [doc = "Interrupt notification of Memory 1 single-bit correction events is disabled."] DISABLE = 0x0 , # [doc = "Interrupt notification of Memory 1 single-bit correction events is enabled."] ENABLE = 0x01 , } impl Escie1 { # [inline (always)] pub const fn from_bits (val : u8) -> Escie1 { unsafe { core :: mem :: transmute (val & 0x01) } } # [inline (always)] pub const fn to_bits (self) -> u8 { unsafe { core :: mem :: transmute (self) } } } impl From < u8 > for Escie1 { # [inline (always)] fn from (val : u8) -> Escie1 { Escie1 :: from_bits (val) } } impl From < Escie1 > for u8 { # [inline (always)] fn from (val : Escie1) -> u8 { Escie1 :: to_bits (val) } } # [repr (u8)] # [derive (Copy , Clone , Debug , Eq , PartialEq , Ord , PartialOrd)] # [cfg_attr (feature = "defmt" , derive (defmt :: Format))] pub enum Nce0 { # [doc = "No non-correctable error event on Memory 0 detected."] NO_ERROR = 0x0 , # [doc = "Non-correctable error event on Memory 0 detected."] ERROR = 0x01 , } impl Nce0 { # [inline (always)] pub const fn from_bits (val : u8) -> Nce0 { unsafe { core :: mem :: transmute (val & 0x01) } } # [inline (always)] pub const fn to_bits (self) -> u8 { unsafe { core :: mem :: transmute (self) } } } impl From < u8 > for Nce0 { # [inline (always)] fn from (val : u8) -> Nce0 { Nce0 :: from_bits (val) } } impl From < Nce0 > for u8 { # [inline (always)] fn from (val : Nce0) -> u8 { Nce0 :: to_bits (val) } } # [repr (u8)] # [derive (Copy , Clone , Debug , Eq , PartialEq , Ord , PartialOrd)] # [cfg_attr (feature = "defmt" , derive (defmt :: Format))] pub enum Nce1 { # [doc = "No non-correctable error event on Memory 1 detected."] NO_ERROR = 0x0 , # [doc = "Non-correctable error event on Memory 1 detected."] ERROR = 0x01 , } impl Nce1 { # [inline (always)] pub const fn from_bits (val : u8) -> Nce1 { unsafe { core :: mem :: transmute (val & 0x01) } } # [inline (always)] pub const fn to_bits (self) -> u8 { unsafe { core :: mem :: transmute (self) } } } impl From < u8 > for Nce1 { # [inline (always)] fn from (val : u8) -> Nce1 { Nce1 :: from_bits (val) } } impl From < Nce1 > for u8 { # [inline (always)] fn from (val : Nce1) -> u8 { Nce1 :: to_bits (val) } } # [repr (u8)] # [derive (Copy , Clone , Debug , Eq , PartialEq , Ord , PartialOrd)] # [cfg_attr (feature = "defmt" , derive (defmt :: Format))] pub enum Sbc0 { # [doc = "No single-bit correction event on Memory 0 detected."] NO_EVENT = 0x0 , # [doc = "Single-bit correction event on Memory 0 detected."] EVENT = 0x01 , } impl Sbc0 { # [inline (always)] pub const fn from_bits (val : u8) -> Sbc0 { unsafe { core :: mem :: transmute (val & 0x01) } } # [inline (always)] pub const fn to_bits (self) -> u8 { unsafe { core :: mem :: transmute (self) } } } impl From < u8 > for Sbc0 { # [inline (always)] fn from (val : u8) -> Sbc0 { Sbc0 :: from_bits (val) } } impl From < Sbc0 > for u8 { # [inline (always)] fn from (val : Sbc0) -> u8 { Sbc0 :: to_bits (val) } } # [repr (u8)] # [derive (Copy , Clone , Debug , Eq , PartialEq , Ord , PartialOrd)] # [cfg_attr (feature = "defmt" , derive (defmt :: Format))] pub enum Sbc1 { # [doc = "No single-bit correction event on Memory 1 detected."] NO_EVENT = 0x0 , # [doc = "Single-bit correction event on Memory 1 detected."] EVENT = 0x01 , } impl Sbc1 { # [inline (always)] pub const fn from_bits (val : u8) -> Sbc1 { unsafe { core :: mem :: transmute (val & 0x01) } } # [inline (always)] pub const fn to_bits (self) -> u8 { unsafe { core :: mem :: transmute (self) } } } impl From < u8 > for Sbc1 { # [inline (always)] fn from (val : u8) -> Sbc1 { Sbc1 :: from_bits (val) } } impl From < Sbc1 > for u8 { # [inline (always)] fn from (val : Sbc1) -> u8 { Sbc1 :: to_bits (val) } }