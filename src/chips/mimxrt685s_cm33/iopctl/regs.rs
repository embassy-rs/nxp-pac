#[doc = "Special Registers (No GPIO Function)"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Fc15I2cScl(pub u32);
impl Fc15I2cScl {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Fc15I2cSclFsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Fc15I2cSclFsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Fc15I2cSclFsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Fc15I2cSclPupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Fc15I2cSclPupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Fc15I2cSclPupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Fc15I2cSclSlewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Fc15I2cSclSlewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Fc15I2cSclSlewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Fc15I2cSclFulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Fc15I2cSclFulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Fc15I2cSclFulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Fc15I2cScl {
    #[inline(always)]
    fn default() -> Fc15I2cScl {
        Fc15I2cScl(0)
    }
}
impl core::fmt::Debug for Fc15I2cScl {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Fc15I2cScl")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Fc15I2cScl {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Fc15I2cScl {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "Special Registers (No GPIO Function)"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Fc15I2cSda(pub u32);
impl Fc15I2cSda {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Fc15I2cSdaFsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Fc15I2cSdaFsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Fc15I2cSdaFsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Fc15I2cSdaPupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Fc15I2cSdaPupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Fc15I2cSdaPupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Fc15I2cSdaSlewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Fc15I2cSdaSlewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Fc15I2cSdaSlewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Fc15I2cSdaFulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Fc15I2cSdaFulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Fc15I2cSdaFulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Fc15I2cSda {
    #[inline(always)]
    fn default() -> Fc15I2cSda {
        Fc15I2cSda(0)
    }
}
impl core::fmt::Debug for Fc15I2cSda {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Fc15I2cSda")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Fc15I2cSda {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Fc15I2cSda {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio00(pub u32);
impl Pio00 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio00Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio00Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio00Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio00Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio00Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio00Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio00Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio00Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio00Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio00Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio00Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio00Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio00 {
    #[inline(always)]
    fn default() -> Pio00 {
        Pio00(0)
    }
}
impl core::fmt::Debug for Pio00 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio00")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio00 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio00 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio01(pub u32);
impl Pio01 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio01Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio01Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio01Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio01Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio01Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio01Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio01Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio01Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio01Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio01Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio01Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio01Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio01 {
    #[inline(always)]
    fn default() -> Pio01 {
        Pio01(0)
    }
}
impl core::fmt::Debug for Pio01 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio01")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio01 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio01 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio010(pub u32);
impl Pio010 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio010Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio010Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio010Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio010Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio010Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio010Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio010Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio010Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio010Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio010Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio010Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio010Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio010 {
    #[inline(always)]
    fn default() -> Pio010 {
        Pio010(0)
    }
}
impl core::fmt::Debug for Pio010 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio010")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio010 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio010 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio011(pub u32);
impl Pio011 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio011Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio011Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio011Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio011Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio011Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio011Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio011Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio011Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio011Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio011Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio011Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio011Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio011 {
    #[inline(always)]
    fn default() -> Pio011 {
        Pio011(0)
    }
}
impl core::fmt::Debug for Pio011 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio011")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio011 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio011 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio012(pub u32);
impl Pio012 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio012Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio012Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio012Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio012Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio012Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio012Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio012Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio012Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio012Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio012Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio012Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio012Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio012 {
    #[inline(always)]
    fn default() -> Pio012 {
        Pio012(0)
    }
}
impl core::fmt::Debug for Pio012 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio012")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio012 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio012 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio013(pub u32);
impl Pio013 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio013Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio013Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio013Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio013Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio013Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio013Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio013Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio013Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio013Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio013Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio013Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio013Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio013 {
    #[inline(always)]
    fn default() -> Pio013 {
        Pio013(0)
    }
}
impl core::fmt::Debug for Pio013 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio013")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio013 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio013 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio014(pub u32);
impl Pio014 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio014Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio014Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio014Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio014Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio014Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio014Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio014Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio014Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio014Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio014Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio014Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio014Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio014 {
    #[inline(always)]
    fn default() -> Pio014 {
        Pio014(0)
    }
}
impl core::fmt::Debug for Pio014 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio014")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio014 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio014 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio015(pub u32);
impl Pio015 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio015Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio015Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio015Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio015Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio015Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio015Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio015Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio015Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio015Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio015Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio015Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio015Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio015 {
    #[inline(always)]
    fn default() -> Pio015 {
        Pio015(0)
    }
}
impl core::fmt::Debug for Pio015 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio015")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio015 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio015 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio016(pub u32);
impl Pio016 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio016Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio016Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio016Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio016Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio016Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio016Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio016Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio016Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio016Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio016Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio016Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio016Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio016 {
    #[inline(always)]
    fn default() -> Pio016 {
        Pio016(0)
    }
}
impl core::fmt::Debug for Pio016 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio016")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio016 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio016 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio017(pub u32);
impl Pio017 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio017Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio017Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio017Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio017Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio017Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio017Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio017Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio017Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio017Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio017Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio017Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio017Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio017 {
    #[inline(always)]
    fn default() -> Pio017 {
        Pio017(0)
    }
}
impl core::fmt::Debug for Pio017 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio017")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio017 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio017 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio018(pub u32);
impl Pio018 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio018Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio018Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio018Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio018Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio018Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio018Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio018Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio018Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio018Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio018Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio018Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio018Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio018 {
    #[inline(always)]
    fn default() -> Pio018 {
        Pio018(0)
    }
}
impl core::fmt::Debug for Pio018 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio018")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio018 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio018 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio019(pub u32);
impl Pio019 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio019Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio019Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio019Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio019Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio019Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio019Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio019Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio019Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio019Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio019Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio019Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio019Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio019 {
    #[inline(always)]
    fn default() -> Pio019 {
        Pio019(0)
    }
}
impl core::fmt::Debug for Pio019 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio019")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio019 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio019 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio02(pub u32);
impl Pio02 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio02Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio02Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio02Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio02Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio02Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio02Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio02Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio02Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio02Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio02Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio02Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio02Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio02 {
    #[inline(always)]
    fn default() -> Pio02 {
        Pio02(0)
    }
}
impl core::fmt::Debug for Pio02 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio02")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio02 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio02 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio020(pub u32);
impl Pio020 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio020Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio020Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio020Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio020Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio020Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio020Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio020Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio020Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio020Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio020Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio020Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio020Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio020 {
    #[inline(always)]
    fn default() -> Pio020 {
        Pio020(0)
    }
}
impl core::fmt::Debug for Pio020 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio020")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio020 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio020 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio021(pub u32);
impl Pio021 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio021Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio021Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio021Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio021Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio021Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio021Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio021Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio021Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio021Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio021Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio021Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio021Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio021 {
    #[inline(always)]
    fn default() -> Pio021 {
        Pio021(0)
    }
}
impl core::fmt::Debug for Pio021 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio021")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio021 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio021 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio022(pub u32);
impl Pio022 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio022Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio022Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio022Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio022Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio022Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio022Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio022Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio022Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio022Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio022Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio022Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio022Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio022 {
    #[inline(always)]
    fn default() -> Pio022 {
        Pio022(0)
    }
}
impl core::fmt::Debug for Pio022 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio022")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio022 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio022 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio023(pub u32);
impl Pio023 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio023Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio023Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio023Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio023Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio023Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio023Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio023Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio023Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio023Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio023Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio023Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio023Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio023 {
    #[inline(always)]
    fn default() -> Pio023 {
        Pio023(0)
    }
}
impl core::fmt::Debug for Pio023 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio023")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio023 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio023 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio024(pub u32);
impl Pio024 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio024Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio024Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio024Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio024Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio024Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio024Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio024Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio024Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio024Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio024Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio024Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio024Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio024 {
    #[inline(always)]
    fn default() -> Pio024 {
        Pio024(0)
    }
}
impl core::fmt::Debug for Pio024 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio024")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio024 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio024 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio025(pub u32);
impl Pio025 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio025Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio025Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio025Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio025Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio025Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio025Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio025Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio025Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio025Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio025Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio025Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio025Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio025 {
    #[inline(always)]
    fn default() -> Pio025 {
        Pio025(0)
    }
}
impl core::fmt::Debug for Pio025 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio025")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio025 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio025 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio026(pub u32);
impl Pio026 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio026Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio026Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio026Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio026Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio026Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio026Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio026Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio026Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio026Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio026Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio026Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio026Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio026 {
    #[inline(always)]
    fn default() -> Pio026 {
        Pio026(0)
    }
}
impl core::fmt::Debug for Pio026 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio026")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio026 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio026 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio027(pub u32);
impl Pio027 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio027Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio027Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio027Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio027Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio027Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio027Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio027Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio027Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio027Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio027Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio027Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio027Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio027 {
    #[inline(always)]
    fn default() -> Pio027 {
        Pio027(0)
    }
}
impl core::fmt::Debug for Pio027 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio027")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio027 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio027 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio028(pub u32);
impl Pio028 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio028Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio028Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio028Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio028Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio028Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio028Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio028Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio028Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio028Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio028Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio028Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio028Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio028 {
    #[inline(always)]
    fn default() -> Pio028 {
        Pio028(0)
    }
}
impl core::fmt::Debug for Pio028 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio028")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio028 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio028 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio029(pub u32);
impl Pio029 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio029Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio029Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio029Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio029Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio029Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio029Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio029Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio029Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio029Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio029Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio029Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio029Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio029 {
    #[inline(always)]
    fn default() -> Pio029 {
        Pio029(0)
    }
}
impl core::fmt::Debug for Pio029 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio029")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio029 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio029 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio03(pub u32);
impl Pio03 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio03Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio03Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio03Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio03Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio03Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio03Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio03Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio03Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio03Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio03Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio03Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio03Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio03 {
    #[inline(always)]
    fn default() -> Pio03 {
        Pio03(0)
    }
}
impl core::fmt::Debug for Pio03 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio03")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio03 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio03 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio030(pub u32);
impl Pio030 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio030Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio030Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio030Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio030Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio030Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio030Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio030Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio030Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio030Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio030Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio030Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio030Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio030 {
    #[inline(always)]
    fn default() -> Pio030 {
        Pio030(0)
    }
}
impl core::fmt::Debug for Pio030 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio030")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio030 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio030 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio031(pub u32);
impl Pio031 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio031Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio031Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio031Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio031Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio031Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio031Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio031Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio031Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio031Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio031Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio031Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio031Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio031 {
    #[inline(always)]
    fn default() -> Pio031 {
        Pio031(0)
    }
}
impl core::fmt::Debug for Pio031 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio031")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio031 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio031 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio04(pub u32);
impl Pio04 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio04Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio04Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio04Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio04Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio04Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio04Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio04Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio04Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio04Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio04Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio04Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio04Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio04 {
    #[inline(always)]
    fn default() -> Pio04 {
        Pio04(0)
    }
}
impl core::fmt::Debug for Pio04 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio04")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio04 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio04 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio05(pub u32);
impl Pio05 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio05Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio05Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio05Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio05Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio05Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio05Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio05Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio05Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio05Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio05Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio05Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio05Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio05 {
    #[inline(always)]
    fn default() -> Pio05 {
        Pio05(0)
    }
}
impl core::fmt::Debug for Pio05 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio05")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio05 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio05 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio06(pub u32);
impl Pio06 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio06Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio06Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio06Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio06Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio06Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio06Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio06Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio06Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio06Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio06Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio06Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio06Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio06 {
    #[inline(always)]
    fn default() -> Pio06 {
        Pio06(0)
    }
}
impl core::fmt::Debug for Pio06 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio06")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio06 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio06 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio07(pub u32);
impl Pio07 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio07Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio07Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio07Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio07Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio07Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio07Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio07Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio07Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio07Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio07Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio07Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio07Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio07 {
    #[inline(always)]
    fn default() -> Pio07 {
        Pio07(0)
    }
}
impl core::fmt::Debug for Pio07 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio07")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio07 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio07 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio08(pub u32);
impl Pio08 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio08Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio08Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio08Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio08Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio08Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio08Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio08Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio08Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio08Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio08Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio08Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio08Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio08 {
    #[inline(always)]
    fn default() -> Pio08 {
        Pio08(0)
    }
}
impl core::fmt::Debug for Pio08 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio08")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio08 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio08 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio09(pub u32);
impl Pio09 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio09Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio09Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio09Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio09Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio09Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio09Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio09Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio09Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio09Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio09Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio09Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio09Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio09 {
    #[inline(always)]
    fn default() -> Pio09 {
        Pio09(0)
    }
}
impl core::fmt::Debug for Pio09 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio09")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio09 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio09 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio10(pub u32);
impl Pio10 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio10Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio10Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio10Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio10Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio10Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio10Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio10Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio10Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio10Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio10Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio10Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio10Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio10 {
    #[inline(always)]
    fn default() -> Pio10 {
        Pio10(0)
    }
}
impl core::fmt::Debug for Pio10 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio10")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio10 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio10 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio11(pub u32);
impl Pio11 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio11Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio11Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio11Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio11Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio11Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio11Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio11Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio11Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio11Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio11Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio11Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio11Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio11 {
    #[inline(always)]
    fn default() -> Pio11 {
        Pio11(0)
    }
}
impl core::fmt::Debug for Pio11 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio11")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio11 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio11 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio110(pub u32);
impl Pio110 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio110Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio110Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio110Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio110Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio110Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio110Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio110Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio110Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio110Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio110Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio110Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio110Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio110 {
    #[inline(always)]
    fn default() -> Pio110 {
        Pio110(0)
    }
}
impl core::fmt::Debug for Pio110 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio110")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio110 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio110 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio111(pub u32);
impl Pio111 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio111Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio111Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio111Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio111Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio111Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio111Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio111Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio111Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio111Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio111Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio111Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio111Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio111 {
    #[inline(always)]
    fn default() -> Pio111 {
        Pio111(0)
    }
}
impl core::fmt::Debug for Pio111 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio111")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio111 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio111 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio112(pub u32);
impl Pio112 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio112Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio112Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio112Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio112Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio112Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio112Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio112Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio112Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio112Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio112Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio112Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio112Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio112 {
    #[inline(always)]
    fn default() -> Pio112 {
        Pio112(0)
    }
}
impl core::fmt::Debug for Pio112 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio112")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio112 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio112 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio113(pub u32);
impl Pio113 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio113Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio113Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio113Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio113Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio113Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio113Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio113Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio113Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio113Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio113Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio113Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio113Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio113 {
    #[inline(always)]
    fn default() -> Pio113 {
        Pio113(0)
    }
}
impl core::fmt::Debug for Pio113 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio113")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio113 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio113 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio114(pub u32);
impl Pio114 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio114Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio114Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio114Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio114Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio114Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio114Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio114Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio114Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio114Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio114Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio114Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio114Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio114 {
    #[inline(always)]
    fn default() -> Pio114 {
        Pio114(0)
    }
}
impl core::fmt::Debug for Pio114 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio114")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio114 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio114 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio115(pub u32);
impl Pio115 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio115Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio115Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio115Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio115Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio115Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio115Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio115Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio115Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio115Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio115Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio115Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio115Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio115 {
    #[inline(always)]
    fn default() -> Pio115 {
        Pio115(0)
    }
}
impl core::fmt::Debug for Pio115 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio115")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio115 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio115 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio116(pub u32);
impl Pio116 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio116Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio116Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio116Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio116Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio116Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio116Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio116Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio116Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio116Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio116Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio116Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio116Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio116 {
    #[inline(always)]
    fn default() -> Pio116 {
        Pio116(0)
    }
}
impl core::fmt::Debug for Pio116 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio116")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio116 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio116 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio117(pub u32);
impl Pio117 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio117Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio117Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio117Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio117Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio117Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio117Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio117Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio117Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio117Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio117Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio117Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio117Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio117 {
    #[inline(always)]
    fn default() -> Pio117 {
        Pio117(0)
    }
}
impl core::fmt::Debug for Pio117 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio117")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio117 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio117 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio118(pub u32);
impl Pio118 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio118Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio118Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio118Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio118Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio118Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio118Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio118Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio118Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio118Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio118Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio118Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio118Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio118 {
    #[inline(always)]
    fn default() -> Pio118 {
        Pio118(0)
    }
}
impl core::fmt::Debug for Pio118 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio118")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio118 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio118 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio119(pub u32);
impl Pio119 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio119Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio119Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio119Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio119Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio119Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio119Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio119Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio119Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio119Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio119Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio119Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio119Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio119 {
    #[inline(always)]
    fn default() -> Pio119 {
        Pio119(0)
    }
}
impl core::fmt::Debug for Pio119 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio119")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio119 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio119 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio12(pub u32);
impl Pio12 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio12Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio12Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio12Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio12Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio12Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio12Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio12Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio12Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio12Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio12Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio12Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio12Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio12 {
    #[inline(always)]
    fn default() -> Pio12 {
        Pio12(0)
    }
}
impl core::fmt::Debug for Pio12 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio12")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio12 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio12 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio120(pub u32);
impl Pio120 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio120Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio120Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio120Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio120Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio120Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio120Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio120Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio120Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio120Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio120Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio120Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio120Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio120 {
    #[inline(always)]
    fn default() -> Pio120 {
        Pio120(0)
    }
}
impl core::fmt::Debug for Pio120 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio120")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio120 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio120 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio121(pub u32);
impl Pio121 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio121Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio121Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio121Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio121Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio121Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio121Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio121Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio121Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio121Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio121Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio121Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio121Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio121 {
    #[inline(always)]
    fn default() -> Pio121 {
        Pio121(0)
    }
}
impl core::fmt::Debug for Pio121 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio121")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio121 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio121 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio122(pub u32);
impl Pio122 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio122Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio122Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio122Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio122Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio122Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio122Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio122Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio122Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio122Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio122Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio122Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio122Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio122 {
    #[inline(always)]
    fn default() -> Pio122 {
        Pio122(0)
    }
}
impl core::fmt::Debug for Pio122 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio122")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio122 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio122 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio123(pub u32);
impl Pio123 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio123Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio123Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio123Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio123Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio123Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio123Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio123Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio123Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio123Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio123Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio123Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio123Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio123 {
    #[inline(always)]
    fn default() -> Pio123 {
        Pio123(0)
    }
}
impl core::fmt::Debug for Pio123 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio123")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio123 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio123 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio124(pub u32);
impl Pio124 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio124Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio124Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio124Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio124Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio124Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio124Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio124Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio124Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio124Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio124Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio124Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio124Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio124 {
    #[inline(always)]
    fn default() -> Pio124 {
        Pio124(0)
    }
}
impl core::fmt::Debug for Pio124 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio124")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio124 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio124 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio125(pub u32);
impl Pio125 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio125Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio125Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio125Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio125Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio125Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio125Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio125Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio125Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio125Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio125Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio125Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio125Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio125 {
    #[inline(always)]
    fn default() -> Pio125 {
        Pio125(0)
    }
}
impl core::fmt::Debug for Pio125 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio125")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio125 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio125 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio126(pub u32);
impl Pio126 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio126Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio126Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio126Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio126Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio126Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio126Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio126Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio126Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio126Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio126Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio126Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio126Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio126 {
    #[inline(always)]
    fn default() -> Pio126 {
        Pio126(0)
    }
}
impl core::fmt::Debug for Pio126 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio126")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio126 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio126 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio127(pub u32);
impl Pio127 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio127Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio127Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio127Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio127Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio127Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio127Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio127Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio127Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio127Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio127Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio127Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio127Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio127 {
    #[inline(always)]
    fn default() -> Pio127 {
        Pio127(0)
    }
}
impl core::fmt::Debug for Pio127 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio127")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio127 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio127 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio128(pub u32);
impl Pio128 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio128Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio128Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio128Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio128Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio128Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio128Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio128Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio128Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio128Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio128Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio128Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio128Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio128 {
    #[inline(always)]
    fn default() -> Pio128 {
        Pio128(0)
    }
}
impl core::fmt::Debug for Pio128 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio128")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio128 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio128 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio129(pub u32);
impl Pio129 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio129Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio129Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio129Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio129Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio129Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio129Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio129Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio129Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio129Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio129Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio129Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio129Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio129 {
    #[inline(always)]
    fn default() -> Pio129 {
        Pio129(0)
    }
}
impl core::fmt::Debug for Pio129 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio129")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio129 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio129 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio13(pub u32);
impl Pio13 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio13Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio13Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio13Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio13Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio13Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio13Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio13Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio13Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio13Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio13Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio13Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio13Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio13 {
    #[inline(always)]
    fn default() -> Pio13 {
        Pio13(0)
    }
}
impl core::fmt::Debug for Pio13 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio13")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio13 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio13 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio130(pub u32);
impl Pio130 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio130Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio130Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio130Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio130Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio130Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio130Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio130Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio130Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio130Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio130Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio130Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio130Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio130 {
    #[inline(always)]
    fn default() -> Pio130 {
        Pio130(0)
    }
}
impl core::fmt::Debug for Pio130 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio130")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio130 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio130 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio131(pub u32);
impl Pio131 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio131Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio131Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio131Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio131Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio131Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio131Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio131Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio131Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio131Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio131Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio131Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio131Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio131 {
    #[inline(always)]
    fn default() -> Pio131 {
        Pio131(0)
    }
}
impl core::fmt::Debug for Pio131 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio131")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio131 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio131 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio14(pub u32);
impl Pio14 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio14Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio14Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio14Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio14Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio14Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio14Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio14Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio14Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio14Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio14Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio14Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio14Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio14 {
    #[inline(always)]
    fn default() -> Pio14 {
        Pio14(0)
    }
}
impl core::fmt::Debug for Pio14 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio14")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio14 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio14 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio15(pub u32);
impl Pio15 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio15Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio15Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio15Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio15Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio15Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio15Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio15Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio15Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio15Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio15Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio15Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio15Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio15 {
    #[inline(always)]
    fn default() -> Pio15 {
        Pio15(0)
    }
}
impl core::fmt::Debug for Pio15 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio15")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio15 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio15 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio16(pub u32);
impl Pio16 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio16Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio16Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio16Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio16Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio16Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio16Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio16Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio16Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio16Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio16Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio16Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio16Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio16 {
    #[inline(always)]
    fn default() -> Pio16 {
        Pio16(0)
    }
}
impl core::fmt::Debug for Pio16 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio16")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio16 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio16 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio17(pub u32);
impl Pio17 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio17Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio17Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio17Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio17Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio17Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio17Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio17Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio17Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio17Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio17Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio17Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio17Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio17 {
    #[inline(always)]
    fn default() -> Pio17 {
        Pio17(0)
    }
}
impl core::fmt::Debug for Pio17 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio17")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio17 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio17 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio18(pub u32);
impl Pio18 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio18Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio18Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio18Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio18Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio18Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio18Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio18Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio18Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio18Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio18Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio18Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio18Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio18 {
    #[inline(always)]
    fn default() -> Pio18 {
        Pio18(0)
    }
}
impl core::fmt::Debug for Pio18 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio18")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio18 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio18 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio19(pub u32);
impl Pio19 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio19Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio19Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio19Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio19Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio19Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio19Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio19Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio19Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio19Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio19Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio19Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio19Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio19 {
    #[inline(always)]
    fn default() -> Pio19 {
        Pio19(0)
    }
}
impl core::fmt::Debug for Pio19 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio19")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio19 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio19 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio20(pub u32);
impl Pio20 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio20Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio20Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio20Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio20Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio20Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio20Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio20Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio20Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio20Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio20Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio20Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio20Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio20 {
    #[inline(always)]
    fn default() -> Pio20 {
        Pio20(0)
    }
}
impl core::fmt::Debug for Pio20 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio20")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio20 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio20 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio21(pub u32);
impl Pio21 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio21Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio21Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio21Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio21Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio21Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio21Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio21Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio21Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio21Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio21Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio21Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio21Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio21 {
    #[inline(always)]
    fn default() -> Pio21 {
        Pio21(0)
    }
}
impl core::fmt::Debug for Pio21 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio21")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio21 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio21 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio210(pub u32);
impl Pio210 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio210Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio210Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio210Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio210Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio210Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio210Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio210Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio210Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio210Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio210Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio210Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio210Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio210 {
    #[inline(always)]
    fn default() -> Pio210 {
        Pio210(0)
    }
}
impl core::fmt::Debug for Pio210 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio210")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio210 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio210 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio211(pub u32);
impl Pio211 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio211Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio211Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio211Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio211Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio211Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio211Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio211Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio211Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio211Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio211Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio211Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio211Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio211 {
    #[inline(always)]
    fn default() -> Pio211 {
        Pio211(0)
    }
}
impl core::fmt::Debug for Pio211 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio211")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio211 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio211 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio212(pub u32);
impl Pio212 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio212Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio212Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio212Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio212Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio212Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio212Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio212Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio212Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio212Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio212Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio212Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio212Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio212 {
    #[inline(always)]
    fn default() -> Pio212 {
        Pio212(0)
    }
}
impl core::fmt::Debug for Pio212 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio212")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio212 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio212 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio213(pub u32);
impl Pio213 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio213Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio213Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio213Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio213Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio213Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio213Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio213Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio213Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio213Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio213Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio213Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio213Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio213 {
    #[inline(always)]
    fn default() -> Pio213 {
        Pio213(0)
    }
}
impl core::fmt::Debug for Pio213 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio213")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio213 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio213 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio214(pub u32);
impl Pio214 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio214Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio214Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio214Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio214Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio214Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio214Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio214Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio214Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio214Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio214Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio214Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio214Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio214 {
    #[inline(always)]
    fn default() -> Pio214 {
        Pio214(0)
    }
}
impl core::fmt::Debug for Pio214 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio214")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio214 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio214 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio215(pub u32);
impl Pio215 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio215Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio215Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio215Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio215Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio215Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio215Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio215Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio215Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio215Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio215Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio215Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio215Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio215 {
    #[inline(always)]
    fn default() -> Pio215 {
        Pio215(0)
    }
}
impl core::fmt::Debug for Pio215 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio215")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio215 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio215 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio216(pub u32);
impl Pio216 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio216Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio216Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio216Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio216Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio216Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio216Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio216Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio216Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio216Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio216Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio216Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio216Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio216 {
    #[inline(always)]
    fn default() -> Pio216 {
        Pio216(0)
    }
}
impl core::fmt::Debug for Pio216 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio216")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio216 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio216 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio217(pub u32);
impl Pio217 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio217Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio217Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio217Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio217Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio217Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio217Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio217Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio217Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio217Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio217Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio217Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio217Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio217 {
    #[inline(always)]
    fn default() -> Pio217 {
        Pio217(0)
    }
}
impl core::fmt::Debug for Pio217 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio217")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio217 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio217 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio218(pub u32);
impl Pio218 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio218Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio218Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio218Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio218Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio218Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio218Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio218Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio218Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio218Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio218Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio218Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio218Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio218 {
    #[inline(always)]
    fn default() -> Pio218 {
        Pio218(0)
    }
}
impl core::fmt::Debug for Pio218 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio218")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio218 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio218 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio219(pub u32);
impl Pio219 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio219Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio219Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio219Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio219Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio219Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio219Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio219Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio219Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio219Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio219Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio219Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio219Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio219 {
    #[inline(always)]
    fn default() -> Pio219 {
        Pio219(0)
    }
}
impl core::fmt::Debug for Pio219 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio219")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio219 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio219 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio22(pub u32);
impl Pio22 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio22Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio22Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio22Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio22Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio22Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio22Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio22Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio22Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio22Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio22Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio22Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio22Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio22 {
    #[inline(always)]
    fn default() -> Pio22 {
        Pio22(0)
    }
}
impl core::fmt::Debug for Pio22 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio22")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio22 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio22 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio220(pub u32);
impl Pio220 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio220Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio220Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio220Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio220Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio220Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio220Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio220Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio220Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio220Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio220Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio220Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio220Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio220 {
    #[inline(always)]
    fn default() -> Pio220 {
        Pio220(0)
    }
}
impl core::fmt::Debug for Pio220 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio220")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio220 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio220 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio221(pub u32);
impl Pio221 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio221Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio221Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio221Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio221Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio221Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio221Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio221Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio221Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio221Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio221Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio221Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio221Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio221 {
    #[inline(always)]
    fn default() -> Pio221 {
        Pio221(0)
    }
}
impl core::fmt::Debug for Pio221 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio221")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio221 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio221 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio222(pub u32);
impl Pio222 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio222Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio222Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio222Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio222Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio222Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio222Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio222Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio222Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio222Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio222Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio222Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio222Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio222 {
    #[inline(always)]
    fn default() -> Pio222 {
        Pio222(0)
    }
}
impl core::fmt::Debug for Pio222 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio222")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio222 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio222 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio223(pub u32);
impl Pio223 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio223Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio223Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio223Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio223Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio223Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio223Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio223Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio223Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio223Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio223Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio223Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio223Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio223 {
    #[inline(always)]
    fn default() -> Pio223 {
        Pio223(0)
    }
}
impl core::fmt::Debug for Pio223 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio223")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio223 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio223 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio224(pub u32);
impl Pio224 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio224Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio224Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio224Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio224Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio224Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio224Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio224Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio224Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio224Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio224Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio224Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio224Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio224 {
    #[inline(always)]
    fn default() -> Pio224 {
        Pio224(0)
    }
}
impl core::fmt::Debug for Pio224 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio224")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio224 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio224 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio225(pub u32);
impl Pio225 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio225Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio225Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio225Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio225Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio225Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio225Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio225Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio225Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio225Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio225Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio225Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio225Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio225 {
    #[inline(always)]
    fn default() -> Pio225 {
        Pio225(0)
    }
}
impl core::fmt::Debug for Pio225 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio225")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio225 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio225 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio226(pub u32);
impl Pio226 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio226Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio226Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio226Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio226Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio226Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio226Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio226Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio226Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio226Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio226Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio226Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio226Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio226 {
    #[inline(always)]
    fn default() -> Pio226 {
        Pio226(0)
    }
}
impl core::fmt::Debug for Pio226 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio226")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio226 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio226 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio227(pub u32);
impl Pio227 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio227Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio227Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio227Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio227Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio227Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio227Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio227Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio227Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio227Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio227Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio227Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio227Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio227 {
    #[inline(always)]
    fn default() -> Pio227 {
        Pio227(0)
    }
}
impl core::fmt::Debug for Pio227 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio227")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio227 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio227 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio228(pub u32);
impl Pio228 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio228Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio228Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio228Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio228Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio228Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio228Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio228Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio228Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio228Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio228Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio228Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio228Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio228 {
    #[inline(always)]
    fn default() -> Pio228 {
        Pio228(0)
    }
}
impl core::fmt::Debug for Pio228 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio228")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio228 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio228 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio229(pub u32);
impl Pio229 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio229Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio229Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio229Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio229Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio229Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio229Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio229Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio229Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio229Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio229Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio229Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio229Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio229 {
    #[inline(always)]
    fn default() -> Pio229 {
        Pio229(0)
    }
}
impl core::fmt::Debug for Pio229 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio229")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio229 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio229 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio23(pub u32);
impl Pio23 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio23Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio23Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio23Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio23Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio23Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio23Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio23Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio23Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio23Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio23Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio23Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio23Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio23 {
    #[inline(always)]
    fn default() -> Pio23 {
        Pio23(0)
    }
}
impl core::fmt::Debug for Pio23 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio23")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio23 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio23 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio230(pub u32);
impl Pio230 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio230Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio230Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio230Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio230Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio230Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio230Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio230Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio230Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio230Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio230Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio230Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio230Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio230 {
    #[inline(always)]
    fn default() -> Pio230 {
        Pio230(0)
    }
}
impl core::fmt::Debug for Pio230 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio230")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio230 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio230 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio231(pub u32);
impl Pio231 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio231Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio231Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio231Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio231Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio231Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio231Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio231Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio231Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio231Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio231Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio231Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio231Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio231 {
    #[inline(always)]
    fn default() -> Pio231 {
        Pio231(0)
    }
}
impl core::fmt::Debug for Pio231 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio231")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio231 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio231 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio24(pub u32);
impl Pio24 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio24Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio24Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio24Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio24Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio24Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio24Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio24Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio24Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio24Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio24Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio24Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio24Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio24 {
    #[inline(always)]
    fn default() -> Pio24 {
        Pio24(0)
    }
}
impl core::fmt::Debug for Pio24 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio24")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio24 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio24 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio25(pub u32);
impl Pio25 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio25Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio25Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio25Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio25Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio25Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio25Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio25Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio25Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio25Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio25Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio25Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio25Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio25 {
    #[inline(always)]
    fn default() -> Pio25 {
        Pio25(0)
    }
}
impl core::fmt::Debug for Pio25 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio25")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio25 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio25 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio26(pub u32);
impl Pio26 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio26Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio26Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio26Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio26Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio26Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio26Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio26Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio26Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio26Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio26Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio26Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio26Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio26 {
    #[inline(always)]
    fn default() -> Pio26 {
        Pio26(0)
    }
}
impl core::fmt::Debug for Pio26 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio26")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio26 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio26 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio27(pub u32);
impl Pio27 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio27Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio27Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio27Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio27Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio27Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio27Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio27Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio27Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio27Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio27Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio27Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio27Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio27 {
    #[inline(always)]
    fn default() -> Pio27 {
        Pio27(0)
    }
}
impl core::fmt::Debug for Pio27 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio27")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio27 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio27 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio28(pub u32);
impl Pio28 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio28Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio28Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio28Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio28Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio28Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio28Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio28Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio28Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio28Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio28Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio28Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio28Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio28 {
    #[inline(always)]
    fn default() -> Pio28 {
        Pio28(0)
    }
}
impl core::fmt::Debug for Pio28 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio28")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio28 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio28 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio29(pub u32);
impl Pio29 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio29Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio29Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio29Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio29Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio29Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio29Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio29Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio29Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio29Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio29Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio29Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio29Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio29 {
    #[inline(always)]
    fn default() -> Pio29 {
        Pio29(0)
    }
}
impl core::fmt::Debug for Pio29 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio29")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio29 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio29 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio30(pub u32);
impl Pio30 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio30Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio30Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio30Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio30Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio30Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio30Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio30Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio30Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio30Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio30Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio30Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio30Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio30 {
    #[inline(always)]
    fn default() -> Pio30 {
        Pio30(0)
    }
}
impl core::fmt::Debug for Pio30 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio30")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio30 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio30 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio31(pub u32);
impl Pio31 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio31Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio31Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio31Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio31Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio31Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio31Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio31Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio31Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio31Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio31Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio31Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio31Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio31 {
    #[inline(always)]
    fn default() -> Pio31 {
        Pio31(0)
    }
}
impl core::fmt::Debug for Pio31 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio31")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio31 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio31 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio310(pub u32);
impl Pio310 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio310Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio310Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio310Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio310Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio310Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio310Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio310Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio310Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio310Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio310Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio310Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio310Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio310 {
    #[inline(always)]
    fn default() -> Pio310 {
        Pio310(0)
    }
}
impl core::fmt::Debug for Pio310 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio310")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio310 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio310 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio311(pub u32);
impl Pio311 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio311Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio311Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio311Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio311Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio311Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio311Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio311Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio311Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio311Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio311Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio311Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio311Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio311 {
    #[inline(always)]
    fn default() -> Pio311 {
        Pio311(0)
    }
}
impl core::fmt::Debug for Pio311 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio311")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio311 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio311 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio312(pub u32);
impl Pio312 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio312Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio312Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio312Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio312Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio312Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio312Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio312Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio312Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio312Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio312Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio312Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio312Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio312 {
    #[inline(always)]
    fn default() -> Pio312 {
        Pio312(0)
    }
}
impl core::fmt::Debug for Pio312 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio312")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio312 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio312 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio313(pub u32);
impl Pio313 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio313Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio313Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio313Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio313Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio313Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio313Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio313Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio313Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio313Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio313Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio313Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio313Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio313 {
    #[inline(always)]
    fn default() -> Pio313 {
        Pio313(0)
    }
}
impl core::fmt::Debug for Pio313 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio313")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio313 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio313 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio314(pub u32);
impl Pio314 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio314Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio314Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio314Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio314Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio314Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio314Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio314Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio314Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio314Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio314Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio314Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio314Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio314 {
    #[inline(always)]
    fn default() -> Pio314 {
        Pio314(0)
    }
}
impl core::fmt::Debug for Pio314 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio314")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio314 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio314 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio315(pub u32);
impl Pio315 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio315Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio315Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio315Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio315Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio315Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio315Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio315Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio315Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio315Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio315Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio315Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio315Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio315 {
    #[inline(always)]
    fn default() -> Pio315 {
        Pio315(0)
    }
}
impl core::fmt::Debug for Pio315 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio315")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio315 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio315 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio316(pub u32);
impl Pio316 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio316Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio316Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio316Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio316Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio316Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio316Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio316Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio316Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio316Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio316Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio316Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio316Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio316 {
    #[inline(always)]
    fn default() -> Pio316 {
        Pio316(0)
    }
}
impl core::fmt::Debug for Pio316 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio316")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio316 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio316 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio317(pub u32);
impl Pio317 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio317Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio317Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio317Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio317Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio317Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio317Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio317Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio317Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio317Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio317Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio317Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio317Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio317 {
    #[inline(always)]
    fn default() -> Pio317 {
        Pio317(0)
    }
}
impl core::fmt::Debug for Pio317 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio317")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio317 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio317 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio318(pub u32);
impl Pio318 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio318Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio318Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio318Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio318Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio318Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio318Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio318Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio318Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio318Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio318Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio318Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio318Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio318 {
    #[inline(always)]
    fn default() -> Pio318 {
        Pio318(0)
    }
}
impl core::fmt::Debug for Pio318 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio318")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio318 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio318 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio319(pub u32);
impl Pio319 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio319Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio319Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio319Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio319Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio319Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio319Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio319Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio319Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio319Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio319Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio319Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio319Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio319 {
    #[inline(always)]
    fn default() -> Pio319 {
        Pio319(0)
    }
}
impl core::fmt::Debug for Pio319 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio319")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio319 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio319 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio32(pub u32);
impl Pio32 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio32Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio32Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio32Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio32Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio32Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio32Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio32Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio32Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio32Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio32Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio32Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio32Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio32 {
    #[inline(always)]
    fn default() -> Pio32 {
        Pio32(0)
    }
}
impl core::fmt::Debug for Pio32 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio32")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio32 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio32 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio320(pub u32);
impl Pio320 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio320Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio320Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio320Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio320Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio320Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio320Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio320Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio320Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio320Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio320Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio320Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio320Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio320 {
    #[inline(always)]
    fn default() -> Pio320 {
        Pio320(0)
    }
}
impl core::fmt::Debug for Pio320 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio320")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio320 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio320 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio321(pub u32);
impl Pio321 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio321Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio321Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio321Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio321Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio321Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio321Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio321Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio321Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio321Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio321Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio321Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio321Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio321 {
    #[inline(always)]
    fn default() -> Pio321 {
        Pio321(0)
    }
}
impl core::fmt::Debug for Pio321 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio321")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio321 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio321 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio322(pub u32);
impl Pio322 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio322Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio322Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio322Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio322Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio322Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio322Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio322Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio322Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio322Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio322Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio322Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio322Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio322 {
    #[inline(always)]
    fn default() -> Pio322 {
        Pio322(0)
    }
}
impl core::fmt::Debug for Pio322 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio322")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio322 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio322 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio323(pub u32);
impl Pio323 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio323Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio323Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio323Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio323Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio323Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio323Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio323Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio323Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio323Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio323Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio323Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio323Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio323 {
    #[inline(always)]
    fn default() -> Pio323 {
        Pio323(0)
    }
}
impl core::fmt::Debug for Pio323 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio323")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio323 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio323 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio324(pub u32);
impl Pio324 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio324Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio324Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio324Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio324Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio324Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio324Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio324Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio324Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio324Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio324Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio324Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio324Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio324 {
    #[inline(always)]
    fn default() -> Pio324 {
        Pio324(0)
    }
}
impl core::fmt::Debug for Pio324 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio324")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio324 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio324 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio325(pub u32);
impl Pio325 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio325Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio325Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio325Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio325Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio325Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio325Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio325Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio325Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio325Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio325Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio325Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio325Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio325 {
    #[inline(always)]
    fn default() -> Pio325 {
        Pio325(0)
    }
}
impl core::fmt::Debug for Pio325 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio325")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio325 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio325 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio326(pub u32);
impl Pio326 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio326Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio326Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio326Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio326Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio326Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio326Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio326Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio326Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio326Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio326Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio326Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio326Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio326 {
    #[inline(always)]
    fn default() -> Pio326 {
        Pio326(0)
    }
}
impl core::fmt::Debug for Pio326 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio326")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio326 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio326 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio327(pub u32);
impl Pio327 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio327Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio327Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio327Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio327Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio327Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio327Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio327Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio327Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio327Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio327Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio327Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio327Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio327 {
    #[inline(always)]
    fn default() -> Pio327 {
        Pio327(0)
    }
}
impl core::fmt::Debug for Pio327 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio327")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio327 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio327 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio328(pub u32);
impl Pio328 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio328Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio328Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio328Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio328Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio328Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio328Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio328Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio328Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio328Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio328Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio328Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio328Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio328 {
    #[inline(always)]
    fn default() -> Pio328 {
        Pio328(0)
    }
}
impl core::fmt::Debug for Pio328 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio328")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio328 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio328 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio329(pub u32);
impl Pio329 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio329Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio329Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio329Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio329Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio329Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio329Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio329Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio329Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio329Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio329Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio329Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio329Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio329 {
    #[inline(always)]
    fn default() -> Pio329 {
        Pio329(0)
    }
}
impl core::fmt::Debug for Pio329 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio329")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio329 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio329 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio33(pub u32);
impl Pio33 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio33Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio33Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio33Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio33Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio33Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio33Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio33Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio33Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio33Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio33Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio33Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio33Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio33 {
    #[inline(always)]
    fn default() -> Pio33 {
        Pio33(0)
    }
}
impl core::fmt::Debug for Pio33 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio33")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio33 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio33 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio330(pub u32);
impl Pio330 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio330Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio330Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio330Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio330Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio330Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio330Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio330Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio330Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio330Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio330Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio330Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio330Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio330 {
    #[inline(always)]
    fn default() -> Pio330 {
        Pio330(0)
    }
}
impl core::fmt::Debug for Pio330 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio330")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio330 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio330 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio331(pub u32);
impl Pio331 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio331Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio331Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio331Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio331Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio331Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio331Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio331Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio331Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio331Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio331Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio331Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio331Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio331 {
    #[inline(always)]
    fn default() -> Pio331 {
        Pio331(0)
    }
}
impl core::fmt::Debug for Pio331 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio331")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio331 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio331 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio34(pub u32);
impl Pio34 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio34Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio34Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio34Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio34Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio34Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio34Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio34Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio34Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio34Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio34Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio34Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio34Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio34 {
    #[inline(always)]
    fn default() -> Pio34 {
        Pio34(0)
    }
}
impl core::fmt::Debug for Pio34 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio34")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio34 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio34 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio35(pub u32);
impl Pio35 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio35Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio35Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio35Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio35Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio35Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio35Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio35Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio35Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio35Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio35Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio35Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio35Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio35 {
    #[inline(always)]
    fn default() -> Pio35 {
        Pio35(0)
    }
}
impl core::fmt::Debug for Pio35 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio35")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio35 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio35 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio36(pub u32);
impl Pio36 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio36Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio36Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio36Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio36Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio36Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio36Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio36Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio36Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio36Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio36Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio36Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio36Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio36 {
    #[inline(always)]
    fn default() -> Pio36 {
        Pio36(0)
    }
}
impl core::fmt::Debug for Pio36 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio36")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio36 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio36 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio37(pub u32);
impl Pio37 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio37Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio37Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio37Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio37Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio37Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio37Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio37Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio37Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio37Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio37Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio37Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio37Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio37 {
    #[inline(always)]
    fn default() -> Pio37 {
        Pio37(0)
    }
}
impl core::fmt::Debug for Pio37 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio37")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio37 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio37 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio38(pub u32);
impl Pio38 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio38Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio38Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio38Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio38Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio38Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio38Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio38Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio38Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio38Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio38Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio38Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio38Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio38 {
    #[inline(always)]
    fn default() -> Pio38 {
        Pio38(0)
    }
}
impl core::fmt::Debug for Pio38 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio38")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio38 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio38 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio39(pub u32);
impl Pio39 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio39Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio39Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio39Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio39Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio39Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio39Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio39Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio39Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio39Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio39Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio39Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio39Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio39 {
    #[inline(always)]
    fn default() -> Pio39 {
        Pio39(0)
    }
}
impl core::fmt::Debug for Pio39 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio39")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio39 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio39 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio40(pub u32);
impl Pio40 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio40Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio40Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio40Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio40Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio40Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio40Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio40Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio40Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio40Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio40Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio40Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio40Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio40 {
    #[inline(always)]
    fn default() -> Pio40 {
        Pio40(0)
    }
}
impl core::fmt::Debug for Pio40 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio40")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio40 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio40 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio41(pub u32);
impl Pio41 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio41Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio41Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio41Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio41Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio41Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio41Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio41Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio41Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio41Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio41Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio41Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio41Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio41 {
    #[inline(always)]
    fn default() -> Pio41 {
        Pio41(0)
    }
}
impl core::fmt::Debug for Pio41 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio41")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio41 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio41 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio410(pub u32);
impl Pio410 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio410Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio410Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio410Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio410Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio410Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio410Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio410Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio410Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio410Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio410Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio410Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio410Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio410 {
    #[inline(always)]
    fn default() -> Pio410 {
        Pio410(0)
    }
}
impl core::fmt::Debug for Pio410 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio410")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio410 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio410 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio411(pub u32);
impl Pio411 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio411Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio411Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio411Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio411Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio411Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio411Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio411Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio411Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio411Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio411Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio411Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio411Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio411 {
    #[inline(always)]
    fn default() -> Pio411 {
        Pio411(0)
    }
}
impl core::fmt::Debug for Pio411 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio411")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio411 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio411 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio412(pub u32);
impl Pio412 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio412Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio412Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio412Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio412Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio412Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio412Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio412Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio412Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio412Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio412Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio412Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio412Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio412 {
    #[inline(always)]
    fn default() -> Pio412 {
        Pio412(0)
    }
}
impl core::fmt::Debug for Pio412 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio412")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio412 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio412 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio413(pub u32);
impl Pio413 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio413Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio413Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio413Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio413Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio413Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio413Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio413Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio413Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio413Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio413Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio413Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio413Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio413 {
    #[inline(always)]
    fn default() -> Pio413 {
        Pio413(0)
    }
}
impl core::fmt::Debug for Pio413 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio413")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio413 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio413 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio414(pub u32);
impl Pio414 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio414Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio414Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio414Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio414Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio414Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio414Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio414Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio414Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio414Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio414Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio414Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio414Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio414 {
    #[inline(always)]
    fn default() -> Pio414 {
        Pio414(0)
    }
}
impl core::fmt::Debug for Pio414 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio414")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio414 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio414 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio415(pub u32);
impl Pio415 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio415Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio415Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio415Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio415Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio415Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio415Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio415Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio415Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio415Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio415Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio415Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio415Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio415 {
    #[inline(always)]
    fn default() -> Pio415 {
        Pio415(0)
    }
}
impl core::fmt::Debug for Pio415 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio415")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio415 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio415 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio416(pub u32);
impl Pio416 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio416Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio416Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio416Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio416Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio416Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio416Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio416Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio416Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio416Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio416Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio416Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio416Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio416 {
    #[inline(always)]
    fn default() -> Pio416 {
        Pio416(0)
    }
}
impl core::fmt::Debug for Pio416 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio416")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio416 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio416 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio417(pub u32);
impl Pio417 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio417Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio417Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio417Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio417Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio417Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio417Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio417Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio417Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio417Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio417Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio417Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio417Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio417 {
    #[inline(always)]
    fn default() -> Pio417 {
        Pio417(0)
    }
}
impl core::fmt::Debug for Pio417 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio417")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio417 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio417 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio418(pub u32);
impl Pio418 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio418Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio418Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio418Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio418Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio418Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio418Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio418Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio418Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio418Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio418Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio418Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio418Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio418 {
    #[inline(always)]
    fn default() -> Pio418 {
        Pio418(0)
    }
}
impl core::fmt::Debug for Pio418 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio418")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio418 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio418 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio419(pub u32);
impl Pio419 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio419Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio419Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio419Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio419Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio419Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio419Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio419Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio419Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio419Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio419Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio419Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio419Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio419 {
    #[inline(always)]
    fn default() -> Pio419 {
        Pio419(0)
    }
}
impl core::fmt::Debug for Pio419 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio419")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio419 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio419 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio42(pub u32);
impl Pio42 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio42Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio42Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio42Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio42Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio42Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio42Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio42Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio42Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio42Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio42Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio42Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio42Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio42 {
    #[inline(always)]
    fn default() -> Pio42 {
        Pio42(0)
    }
}
impl core::fmt::Debug for Pio42 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio42")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio42 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio42 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio420(pub u32);
impl Pio420 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio420Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio420Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio420Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio420Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio420Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio420Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio420Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio420Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio420Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio420Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio420Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio420Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio420 {
    #[inline(always)]
    fn default() -> Pio420 {
        Pio420(0)
    }
}
impl core::fmt::Debug for Pio420 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio420")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio420 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio420 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio421(pub u32);
impl Pio421 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio421Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio421Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio421Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio421Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio421Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio421Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio421Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio421Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio421Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio421Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio421Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio421Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio421 {
    #[inline(always)]
    fn default() -> Pio421 {
        Pio421(0)
    }
}
impl core::fmt::Debug for Pio421 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio421")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio421 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio421 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio422(pub u32);
impl Pio422 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio422Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio422Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio422Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio422Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio422Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio422Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio422Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio422Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio422Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio422Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio422Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio422Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio422 {
    #[inline(always)]
    fn default() -> Pio422 {
        Pio422(0)
    }
}
impl core::fmt::Debug for Pio422 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio422")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio422 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio422 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio423(pub u32);
impl Pio423 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio423Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio423Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio423Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio423Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio423Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio423Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio423Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio423Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio423Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio423Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio423Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio423Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio423 {
    #[inline(always)]
    fn default() -> Pio423 {
        Pio423(0)
    }
}
impl core::fmt::Debug for Pio423 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio423")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio423 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio423 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio424(pub u32);
impl Pio424 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio424Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio424Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio424Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio424Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio424Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio424Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio424Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio424Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio424Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio424Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio424Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio424Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio424 {
    #[inline(always)]
    fn default() -> Pio424 {
        Pio424(0)
    }
}
impl core::fmt::Debug for Pio424 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio424")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio424 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio424 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio425(pub u32);
impl Pio425 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio425Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio425Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio425Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio425Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio425Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio425Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio425Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio425Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio425Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio425Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio425Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio425Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio425 {
    #[inline(always)]
    fn default() -> Pio425 {
        Pio425(0)
    }
}
impl core::fmt::Debug for Pio425 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio425")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio425 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio425 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio426(pub u32);
impl Pio426 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio426Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio426Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio426Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio426Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio426Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio426Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio426Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio426Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio426Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio426Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio426Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio426Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio426 {
    #[inline(always)]
    fn default() -> Pio426 {
        Pio426(0)
    }
}
impl core::fmt::Debug for Pio426 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio426")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio426 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio426 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio427(pub u32);
impl Pio427 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio427Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio427Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio427Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio427Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio427Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio427Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio427Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio427Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio427Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio427Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio427Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio427Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio427 {
    #[inline(always)]
    fn default() -> Pio427 {
        Pio427(0)
    }
}
impl core::fmt::Debug for Pio427 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio427")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio427 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio427 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio428(pub u32);
impl Pio428 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio428Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio428Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio428Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio428Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio428Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio428Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio428Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio428Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio428Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio428Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio428Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio428Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio428 {
    #[inline(always)]
    fn default() -> Pio428 {
        Pio428(0)
    }
}
impl core::fmt::Debug for Pio428 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio428")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio428 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio428 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio429(pub u32);
impl Pio429 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio429Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio429Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio429Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio429Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio429Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio429Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio429Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio429Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio429Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio429Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio429Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio429Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio429 {
    #[inline(always)]
    fn default() -> Pio429 {
        Pio429(0)
    }
}
impl core::fmt::Debug for Pio429 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio429")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio429 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio429 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio43(pub u32);
impl Pio43 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio43Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio43Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio43Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio43Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio43Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio43Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio43Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio43Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio43Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio43Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio43Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio43Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio43 {
    #[inline(always)]
    fn default() -> Pio43 {
        Pio43(0)
    }
}
impl core::fmt::Debug for Pio43 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio43")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio43 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio43 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio430(pub u32);
impl Pio430 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio430Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio430Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio430Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio430Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio430Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio430Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio430Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio430Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio430Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio430Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio430Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio430Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio430 {
    #[inline(always)]
    fn default() -> Pio430 {
        Pio430(0)
    }
}
impl core::fmt::Debug for Pio430 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio430")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio430 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio430 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio431(pub u32);
impl Pio431 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio431Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio431Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio431Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio431Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio431Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio431Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio431Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio431Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio431Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio431Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio431Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio431Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio431 {
    #[inline(always)]
    fn default() -> Pio431 {
        Pio431(0)
    }
}
impl core::fmt::Debug for Pio431 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio431")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio431 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio431 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio44(pub u32);
impl Pio44 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio44Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio44Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio44Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio44Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio44Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio44Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio44Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio44Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio44Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio44Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio44Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio44Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio44 {
    #[inline(always)]
    fn default() -> Pio44 {
        Pio44(0)
    }
}
impl core::fmt::Debug for Pio44 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio44")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio44 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio44 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio45(pub u32);
impl Pio45 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio45Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio45Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio45Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio45Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio45Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio45Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio45Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio45Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio45Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio45Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio45Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio45Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio45 {
    #[inline(always)]
    fn default() -> Pio45 {
        Pio45(0)
    }
}
impl core::fmt::Debug for Pio45 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio45")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio45 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio45 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio46(pub u32);
impl Pio46 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio46Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio46Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio46Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio46Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio46Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio46Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio46Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio46Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio46Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio46Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio46Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio46Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio46 {
    #[inline(always)]
    fn default() -> Pio46 {
        Pio46(0)
    }
}
impl core::fmt::Debug for Pio46 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio46")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio46 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio46 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio47(pub u32);
impl Pio47 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio47Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio47Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio47Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio47Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio47Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio47Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio47Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio47Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio47Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio47Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio47Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio47Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio47 {
    #[inline(always)]
    fn default() -> Pio47 {
        Pio47(0)
    }
}
impl core::fmt::Debug for Pio47 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio47")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio47 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio47 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio48(pub u32);
impl Pio48 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio48Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio48Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio48Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio48Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio48Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio48Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio48Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio48Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio48Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio48Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio48Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio48Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio48 {
    #[inline(always)]
    fn default() -> Pio48 {
        Pio48(0)
    }
}
impl core::fmt::Debug for Pio48 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio48")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio48 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio48 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio49(pub u32);
impl Pio49 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio49Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio49Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio49Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio49Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio49Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio49Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio49Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio49Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio49Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio49Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio49Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio49Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio49 {
    #[inline(always)]
    fn default() -> Pio49 {
        Pio49(0)
    }
}
impl core::fmt::Debug for Pio49 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio49")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio49 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio49 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio50(pub u32);
impl Pio50 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio50Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio50Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio50Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio50Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio50Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio50Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio50Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio50Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio50Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio50Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio50Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio50Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio50 {
    #[inline(always)]
    fn default() -> Pio50 {
        Pio50(0)
    }
}
impl core::fmt::Debug for Pio50 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio50")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio50 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio50 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio51(pub u32);
impl Pio51 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio51Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio51Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio51Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio51Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio51Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio51Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio51Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio51Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio51Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio51Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio51Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio51Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio51 {
    #[inline(always)]
    fn default() -> Pio51 {
        Pio51(0)
    }
}
impl core::fmt::Debug for Pio51 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio51")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio51 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio51 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio510(pub u32);
impl Pio510 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio510Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio510Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio510Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio510Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio510Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio510Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio510Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio510Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio510Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio510Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio510Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio510Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio510 {
    #[inline(always)]
    fn default() -> Pio510 {
        Pio510(0)
    }
}
impl core::fmt::Debug for Pio510 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio510")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio510 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio510 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio511(pub u32);
impl Pio511 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio511Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio511Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio511Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio511Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio511Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio511Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio511Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio511Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio511Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio511Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio511Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio511Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio511 {
    #[inline(always)]
    fn default() -> Pio511 {
        Pio511(0)
    }
}
impl core::fmt::Debug for Pio511 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio511")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio511 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio511 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio512(pub u32);
impl Pio512 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio512Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio512Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio512Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio512Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio512Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio512Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio512Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio512Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio512Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio512Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio512Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio512Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio512 {
    #[inline(always)]
    fn default() -> Pio512 {
        Pio512(0)
    }
}
impl core::fmt::Debug for Pio512 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio512")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio512 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio512 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio513(pub u32);
impl Pio513 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio513Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio513Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio513Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio513Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio513Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio513Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio513Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio513Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio513Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio513Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio513Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio513Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio513 {
    #[inline(always)]
    fn default() -> Pio513 {
        Pio513(0)
    }
}
impl core::fmt::Debug for Pio513 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio513")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio513 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio513 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio514(pub u32);
impl Pio514 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio514Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio514Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio514Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio514Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio514Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio514Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio514Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio514Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio514Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio514Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio514Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio514Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio514 {
    #[inline(always)]
    fn default() -> Pio514 {
        Pio514(0)
    }
}
impl core::fmt::Debug for Pio514 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio514")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio514 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio514 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio515(pub u32);
impl Pio515 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio515Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio515Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio515Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio515Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio515Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio515Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio515Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio515Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio515Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio515Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio515Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio515Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio515 {
    #[inline(always)]
    fn default() -> Pio515 {
        Pio515(0)
    }
}
impl core::fmt::Debug for Pio515 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio515")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio515 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio515 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio516(pub u32);
impl Pio516 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio516Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio516Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio516Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio516Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio516Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio516Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio516Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio516Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio516Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio516Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio516Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio516Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio516 {
    #[inline(always)]
    fn default() -> Pio516 {
        Pio516(0)
    }
}
impl core::fmt::Debug for Pio516 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio516")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio516 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio516 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio517(pub u32);
impl Pio517 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio517Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio517Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio517Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio517Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio517Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio517Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio517Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio517Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio517Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio517Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio517Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio517Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio517 {
    #[inline(always)]
    fn default() -> Pio517 {
        Pio517(0)
    }
}
impl core::fmt::Debug for Pio517 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio517")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio517 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio517 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio518(pub u32);
impl Pio518 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio518Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio518Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio518Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio518Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio518Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio518Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio518Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio518Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio518Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio518Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio518Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio518Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio518 {
    #[inline(always)]
    fn default() -> Pio518 {
        Pio518(0)
    }
}
impl core::fmt::Debug for Pio518 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio518")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio518 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio518 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio519(pub u32);
impl Pio519 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio519Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio519Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio519Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio519Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio519Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio519Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio519Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio519Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio519Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio519Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio519Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio519Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio519 {
    #[inline(always)]
    fn default() -> Pio519 {
        Pio519(0)
    }
}
impl core::fmt::Debug for Pio519 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio519")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio519 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio519 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio52(pub u32);
impl Pio52 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio52Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio52Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio52Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio52Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio52Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio52Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio52Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio52Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio52Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio52Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio52Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio52Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio52 {
    #[inline(always)]
    fn default() -> Pio52 {
        Pio52(0)
    }
}
impl core::fmt::Debug for Pio52 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio52")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio52 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio52 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio520(pub u32);
impl Pio520 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio520Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio520Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio520Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio520Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio520Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio520Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio520Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio520Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio520Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio520Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio520Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio520Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio520 {
    #[inline(always)]
    fn default() -> Pio520 {
        Pio520(0)
    }
}
impl core::fmt::Debug for Pio520 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio520")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio520 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio520 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio521(pub u32);
impl Pio521 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio521Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio521Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio521Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio521Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio521Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio521Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio521Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio521Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio521Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio521Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio521Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio521Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio521 {
    #[inline(always)]
    fn default() -> Pio521 {
        Pio521(0)
    }
}
impl core::fmt::Debug for Pio521 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio521")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio521 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio521 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio522(pub u32);
impl Pio522 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio522Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio522Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio522Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio522Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio522Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio522Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio522Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio522Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio522Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio522Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio522Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio522Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio522 {
    #[inline(always)]
    fn default() -> Pio522 {
        Pio522(0)
    }
}
impl core::fmt::Debug for Pio522 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio522")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio522 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio522 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio523(pub u32);
impl Pio523 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio523Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio523Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio523Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio523Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio523Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio523Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio523Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio523Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio523Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio523Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio523Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio523Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio523 {
    #[inline(always)]
    fn default() -> Pio523 {
        Pio523(0)
    }
}
impl core::fmt::Debug for Pio523 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio523")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio523 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio523 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio524(pub u32);
impl Pio524 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio524Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio524Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio524Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio524Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio524Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio524Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio524Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio524Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio524Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio524Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio524Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio524Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio524 {
    #[inline(always)]
    fn default() -> Pio524 {
        Pio524(0)
    }
}
impl core::fmt::Debug for Pio524 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio524")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio524 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio524 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio525(pub u32);
impl Pio525 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio525Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio525Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio525Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio525Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio525Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio525Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio525Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio525Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio525Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio525Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio525Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio525Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio525 {
    #[inline(always)]
    fn default() -> Pio525 {
        Pio525(0)
    }
}
impl core::fmt::Debug for Pio525 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio525")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio525 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio525 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio526(pub u32);
impl Pio526 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio526Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio526Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio526Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio526Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio526Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio526Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio526Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio526Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio526Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio526Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio526Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio526Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio526 {
    #[inline(always)]
    fn default() -> Pio526 {
        Pio526(0)
    }
}
impl core::fmt::Debug for Pio526 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio526")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio526 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio526 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio527(pub u32);
impl Pio527 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio527Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio527Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio527Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio527Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio527Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio527Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio527Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio527Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio527Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio527Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio527Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio527Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio527 {
    #[inline(always)]
    fn default() -> Pio527 {
        Pio527(0)
    }
}
impl core::fmt::Debug for Pio527 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio527")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio527 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio527 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio528(pub u32);
impl Pio528 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio528Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio528Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio528Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio528Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio528Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio528Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio528Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio528Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio528Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio528Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio528Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio528Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio528 {
    #[inline(always)]
    fn default() -> Pio528 {
        Pio528(0)
    }
}
impl core::fmt::Debug for Pio528 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio528")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio528 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio528 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio529(pub u32);
impl Pio529 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio529Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio529Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio529Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio529Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio529Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio529Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio529Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio529Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio529Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio529Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio529Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio529Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio529 {
    #[inline(always)]
    fn default() -> Pio529 {
        Pio529(0)
    }
}
impl core::fmt::Debug for Pio529 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio529")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio529 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio529 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio53(pub u32);
impl Pio53 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio53Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio53Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio53Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio53Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio53Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio53Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio53Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio53Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio53Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio53Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio53Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio53Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio53 {
    #[inline(always)]
    fn default() -> Pio53 {
        Pio53(0)
    }
}
impl core::fmt::Debug for Pio53 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio53")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio53 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio53 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio530(pub u32);
impl Pio530 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio530Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio530Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio530Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio530Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio530Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio530Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio530Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio530Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio530Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio530Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio530Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio530Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio530 {
    #[inline(always)]
    fn default() -> Pio530 {
        Pio530(0)
    }
}
impl core::fmt::Debug for Pio530 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio530")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio530 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio530 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio531(pub u32);
impl Pio531 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio531Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio531Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio531Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio531Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio531Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio531Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio531Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio531Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio531Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio531Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio531Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio531Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio531 {
    #[inline(always)]
    fn default() -> Pio531 {
        Pio531(0)
    }
}
impl core::fmt::Debug for Pio531 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio531")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio531 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio531 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio54(pub u32);
impl Pio54 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio54Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio54Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio54Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio54Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio54Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio54Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio54Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio54Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio54Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio54Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio54Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio54Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio54 {
    #[inline(always)]
    fn default() -> Pio54 {
        Pio54(0)
    }
}
impl core::fmt::Debug for Pio54 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio54")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio54 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio54 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio55(pub u32);
impl Pio55 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio55Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio55Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio55Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio55Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio55Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio55Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio55Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio55Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio55Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio55Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio55Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio55Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio55 {
    #[inline(always)]
    fn default() -> Pio55 {
        Pio55(0)
    }
}
impl core::fmt::Debug for Pio55 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio55")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio55 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio55 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio56(pub u32);
impl Pio56 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio56Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio56Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio56Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio56Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio56Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio56Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio56Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio56Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio56Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio56Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio56Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio56Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio56 {
    #[inline(always)]
    fn default() -> Pio56 {
        Pio56(0)
    }
}
impl core::fmt::Debug for Pio56 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio56")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio56 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio56 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio57(pub u32);
impl Pio57 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio57Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio57Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio57Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio57Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio57Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio57Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio57Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio57Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio57Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio57Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio57Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio57Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio57 {
    #[inline(always)]
    fn default() -> Pio57 {
        Pio57(0)
    }
}
impl core::fmt::Debug for Pio57 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio57")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio57 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio57 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio58(pub u32);
impl Pio58 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio58Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio58Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio58Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio58Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio58Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio58Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio58Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio58Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio58Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio58Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio58Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio58Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio58 {
    #[inline(always)]
    fn default() -> Pio58 {
        Pio58(0)
    }
}
impl core::fmt::Debug for Pio58 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio58")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio58 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio58 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio59(pub u32);
impl Pio59 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio59Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio59Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio59Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio59Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio59Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio59Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio59Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio59Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio59Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio59Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio59Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio59Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio59 {
    #[inline(always)]
    fn default() -> Pio59 {
        Pio59(0)
    }
}
impl core::fmt::Debug for Pio59 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio59")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio59 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio59 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio60(pub u32);
impl Pio60 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio60Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio60Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio60Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio60Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio60Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio60Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio60Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio60Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio60Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio60Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio60Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio60Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio60 {
    #[inline(always)]
    fn default() -> Pio60 {
        Pio60(0)
    }
}
impl core::fmt::Debug for Pio60 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio60")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio60 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio60 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio61(pub u32);
impl Pio61 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio61Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio61Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio61Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio61Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio61Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio61Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio61Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio61Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio61Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio61Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio61Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio61Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio61 {
    #[inline(always)]
    fn default() -> Pio61 {
        Pio61(0)
    }
}
impl core::fmt::Debug for Pio61 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio61")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio61 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio61 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio610(pub u32);
impl Pio610 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio610Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio610Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio610Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio610Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio610Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio610Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio610Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio610Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio610Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio610Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio610Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio610Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio610 {
    #[inline(always)]
    fn default() -> Pio610 {
        Pio610(0)
    }
}
impl core::fmt::Debug for Pio610 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio610")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio610 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio610 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio611(pub u32);
impl Pio611 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio611Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio611Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio611Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio611Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio611Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio611Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio611Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio611Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio611Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio611Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio611Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio611Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio611 {
    #[inline(always)]
    fn default() -> Pio611 {
        Pio611(0)
    }
}
impl core::fmt::Debug for Pio611 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio611")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio611 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio611 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio612(pub u32);
impl Pio612 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio612Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio612Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio612Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio612Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio612Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio612Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio612Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio612Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio612Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio612Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio612Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio612Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio612 {
    #[inline(always)]
    fn default() -> Pio612 {
        Pio612(0)
    }
}
impl core::fmt::Debug for Pio612 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio612")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio612 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio612 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio613(pub u32);
impl Pio613 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio613Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio613Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio613Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio613Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio613Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio613Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio613Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio613Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio613Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio613Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio613Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio613Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio613 {
    #[inline(always)]
    fn default() -> Pio613 {
        Pio613(0)
    }
}
impl core::fmt::Debug for Pio613 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio613")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio613 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio613 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio614(pub u32);
impl Pio614 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio614Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio614Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio614Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio614Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio614Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio614Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio614Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio614Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio614Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio614Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio614Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio614Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio614 {
    #[inline(always)]
    fn default() -> Pio614 {
        Pio614(0)
    }
}
impl core::fmt::Debug for Pio614 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio614")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio614 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio614 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio615(pub u32);
impl Pio615 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio615Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio615Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio615Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio615Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio615Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio615Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio615Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio615Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio615Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio615Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio615Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio615Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio615 {
    #[inline(always)]
    fn default() -> Pio615 {
        Pio615(0)
    }
}
impl core::fmt::Debug for Pio615 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio615")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio615 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio615 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio616(pub u32);
impl Pio616 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio616Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio616Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio616Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio616Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio616Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio616Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio616Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio616Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio616Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio616Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio616Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio616Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio616 {
    #[inline(always)]
    fn default() -> Pio616 {
        Pio616(0)
    }
}
impl core::fmt::Debug for Pio616 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio616")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio616 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio616 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio617(pub u32);
impl Pio617 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio617Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio617Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio617Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio617Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio617Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio617Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio617Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio617Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio617Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio617Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio617Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio617Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio617 {
    #[inline(always)]
    fn default() -> Pio617 {
        Pio617(0)
    }
}
impl core::fmt::Debug for Pio617 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio617")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio617 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio617 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio618(pub u32);
impl Pio618 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio618Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio618Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio618Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio618Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio618Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio618Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio618Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio618Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio618Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio618Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio618Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio618Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio618 {
    #[inline(always)]
    fn default() -> Pio618 {
        Pio618(0)
    }
}
impl core::fmt::Debug for Pio618 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio618")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio618 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio618 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio619(pub u32);
impl Pio619 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio619Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio619Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio619Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio619Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio619Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio619Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio619Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio619Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio619Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio619Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio619Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio619Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio619 {
    #[inline(always)]
    fn default() -> Pio619 {
        Pio619(0)
    }
}
impl core::fmt::Debug for Pio619 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio619")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio619 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio619 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio62(pub u32);
impl Pio62 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio62Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio62Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio62Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio62Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio62Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio62Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio62Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio62Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio62Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio62Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio62Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio62Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio62 {
    #[inline(always)]
    fn default() -> Pio62 {
        Pio62(0)
    }
}
impl core::fmt::Debug for Pio62 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio62")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio62 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio62 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio620(pub u32);
impl Pio620 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio620Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio620Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio620Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio620Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio620Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio620Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio620Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio620Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio620Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio620Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio620Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio620Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio620 {
    #[inline(always)]
    fn default() -> Pio620 {
        Pio620(0)
    }
}
impl core::fmt::Debug for Pio620 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio620")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio620 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio620 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio621(pub u32);
impl Pio621 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio621Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio621Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio621Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio621Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio621Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio621Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio621Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio621Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio621Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio621Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio621Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio621Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio621 {
    #[inline(always)]
    fn default() -> Pio621 {
        Pio621(0)
    }
}
impl core::fmt::Debug for Pio621 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio621")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio621 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio621 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio622(pub u32);
impl Pio622 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio622Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio622Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio622Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio622Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio622Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio622Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio622Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio622Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio622Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio622Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio622Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio622Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio622 {
    #[inline(always)]
    fn default() -> Pio622 {
        Pio622(0)
    }
}
impl core::fmt::Debug for Pio622 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio622")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio622 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio622 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio623(pub u32);
impl Pio623 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio623Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio623Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio623Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio623Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio623Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio623Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio623Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio623Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio623Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio623Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio623Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio623Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio623 {
    #[inline(always)]
    fn default() -> Pio623 {
        Pio623(0)
    }
}
impl core::fmt::Debug for Pio623 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio623")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio623 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio623 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio624(pub u32);
impl Pio624 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio624Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio624Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio624Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio624Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio624Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio624Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio624Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio624Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio624Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio624Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio624Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio624Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio624 {
    #[inline(always)]
    fn default() -> Pio624 {
        Pio624(0)
    }
}
impl core::fmt::Debug for Pio624 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio624")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio624 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio624 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio625(pub u32);
impl Pio625 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio625Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio625Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio625Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio625Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio625Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio625Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio625Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio625Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio625Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio625Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio625Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio625Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio625 {
    #[inline(always)]
    fn default() -> Pio625 {
        Pio625(0)
    }
}
impl core::fmt::Debug for Pio625 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio625")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio625 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio625 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio626(pub u32);
impl Pio626 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio626Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio626Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio626Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio626Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio626Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio626Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio626Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio626Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio626Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio626Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio626Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio626Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio626 {
    #[inline(always)]
    fn default() -> Pio626 {
        Pio626(0)
    }
}
impl core::fmt::Debug for Pio626 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio626")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio626 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio626 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio627(pub u32);
impl Pio627 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio627Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio627Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio627Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio627Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio627Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio627Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio627Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio627Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio627Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio627Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio627Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio627Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio627 {
    #[inline(always)]
    fn default() -> Pio627 {
        Pio627(0)
    }
}
impl core::fmt::Debug for Pio627 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio627")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio627 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio627 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio628(pub u32);
impl Pio628 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio628Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio628Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio628Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio628Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio628Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio628Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio628Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio628Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio628Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio628Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio628Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio628Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio628 {
    #[inline(always)]
    fn default() -> Pio628 {
        Pio628(0)
    }
}
impl core::fmt::Debug for Pio628 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio628")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio628 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio628 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio629(pub u32);
impl Pio629 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio629Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio629Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio629Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio629Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio629Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio629Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio629Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio629Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio629Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio629Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio629Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio629Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio629 {
    #[inline(always)]
    fn default() -> Pio629 {
        Pio629(0)
    }
}
impl core::fmt::Debug for Pio629 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio629")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio629 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio629 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio63(pub u32);
impl Pio63 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio63Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio63Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio63Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio63Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio63Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio63Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio63Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio63Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio63Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio63Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio63Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio63Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio63 {
    #[inline(always)]
    fn default() -> Pio63 {
        Pio63(0)
    }
}
impl core::fmt::Debug for Pio63 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio63")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio63 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio63 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio630(pub u32);
impl Pio630 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio630Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio630Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio630Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio630Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio630Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio630Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio630Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio630Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio630Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio630Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio630Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio630Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio630 {
    #[inline(always)]
    fn default() -> Pio630 {
        Pio630(0)
    }
}
impl core::fmt::Debug for Pio630 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio630")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio630 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio630 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio631(pub u32);
impl Pio631 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio631Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio631Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio631Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio631Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio631Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio631Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio631Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio631Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio631Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio631Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio631Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio631Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio631 {
    #[inline(always)]
    fn default() -> Pio631 {
        Pio631(0)
    }
}
impl core::fmt::Debug for Pio631 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio631")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio631 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio631 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio64(pub u32);
impl Pio64 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio64Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio64Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio64Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio64Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio64Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio64Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio64Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio64Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio64Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio64Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio64Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio64Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio64 {
    #[inline(always)]
    fn default() -> Pio64 {
        Pio64(0)
    }
}
impl core::fmt::Debug for Pio64 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio64")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio64 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio64 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio65(pub u32);
impl Pio65 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio65Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio65Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio65Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio65Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio65Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio65Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio65Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio65Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio65Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio65Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio65Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio65Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio65 {
    #[inline(always)]
    fn default() -> Pio65 {
        Pio65(0)
    }
}
impl core::fmt::Debug for Pio65 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio65")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio65 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio65 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio66(pub u32);
impl Pio66 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio66Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio66Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio66Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio66Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio66Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio66Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio66Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio66Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio66Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio66Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio66Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio66Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio66 {
    #[inline(always)]
    fn default() -> Pio66 {
        Pio66(0)
    }
}
impl core::fmt::Debug for Pio66 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio66")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio66 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio66 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio67(pub u32);
impl Pio67 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio67Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio67Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio67Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio67Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio67Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio67Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio67Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio67Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio67Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio67Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio67Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio67Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio67 {
    #[inline(always)]
    fn default() -> Pio67 {
        Pio67(0)
    }
}
impl core::fmt::Debug for Pio67 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio67")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio67 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio67 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio68(pub u32);
impl Pio68 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio68Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio68Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio68Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio68Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio68Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio68Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio68Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio68Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio68Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio68Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio68Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio68Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio68 {
    #[inline(always)]
    fn default() -> Pio68 {
        Pio68(0)
    }
}
impl core::fmt::Debug for Pio68 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio68")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio68 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio68 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio69(pub u32);
impl Pio69 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio69Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio69Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio69Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio69Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio69Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio69Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio69Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio69Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio69Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio69Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio69Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio69Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio69 {
    #[inline(always)]
    fn default() -> Pio69 {
        Pio69(0)
    }
}
impl core::fmt::Debug for Pio69 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio69")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio69 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio69 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio70(pub u32);
impl Pio70 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio70Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio70Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio70Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio70Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio70Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio70Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio70Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio70Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio70Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio70Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio70Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio70Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio70 {
    #[inline(always)]
    fn default() -> Pio70 {
        Pio70(0)
    }
}
impl core::fmt::Debug for Pio70 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio70")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio70 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio70 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio71(pub u32);
impl Pio71 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio71Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio71Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio71Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio71Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio71Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio71Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio71Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio71Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio71Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio71Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio71Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio71Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio71 {
    #[inline(always)]
    fn default() -> Pio71 {
        Pio71(0)
    }
}
impl core::fmt::Debug for Pio71 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio71")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio71 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio71 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio710(pub u32);
impl Pio710 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio710Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio710Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio710Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio710Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio710Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio710Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio710Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio710Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio710Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio710Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio710Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio710Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio710 {
    #[inline(always)]
    fn default() -> Pio710 {
        Pio710(0)
    }
}
impl core::fmt::Debug for Pio710 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio710")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio710 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio710 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio711(pub u32);
impl Pio711 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio711Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio711Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio711Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio711Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio711Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio711Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio711Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio711Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio711Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio711Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio711Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio711Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio711 {
    #[inline(always)]
    fn default() -> Pio711 {
        Pio711(0)
    }
}
impl core::fmt::Debug for Pio711 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio711")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio711 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio711 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio712(pub u32);
impl Pio712 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio712Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio712Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio712Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio712Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio712Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio712Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio712Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio712Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio712Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio712Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio712Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio712Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio712 {
    #[inline(always)]
    fn default() -> Pio712 {
        Pio712(0)
    }
}
impl core::fmt::Debug for Pio712 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio712")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio712 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio712 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio713(pub u32);
impl Pio713 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio713Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio713Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio713Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio713Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio713Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio713Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio713Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio713Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio713Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio713Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio713Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio713Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio713 {
    #[inline(always)]
    fn default() -> Pio713 {
        Pio713(0)
    }
}
impl core::fmt::Debug for Pio713 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio713")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio713 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio713 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio714(pub u32);
impl Pio714 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio714Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio714Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio714Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio714Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio714Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio714Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio714Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio714Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio714Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio714Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio714Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio714Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio714 {
    #[inline(always)]
    fn default() -> Pio714 {
        Pio714(0)
    }
}
impl core::fmt::Debug for Pio714 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio714")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio714 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio714 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio715(pub u32);
impl Pio715 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio715Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio715Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio715Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio715Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio715Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio715Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio715Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio715Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio715Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio715Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio715Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio715Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio715 {
    #[inline(always)]
    fn default() -> Pio715 {
        Pio715(0)
    }
}
impl core::fmt::Debug for Pio715 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio715")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio715 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio715 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio716(pub u32);
impl Pio716 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio716Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio716Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio716Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio716Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio716Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio716Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio716Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio716Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio716Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio716Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio716Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio716Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio716 {
    #[inline(always)]
    fn default() -> Pio716 {
        Pio716(0)
    }
}
impl core::fmt::Debug for Pio716 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio716")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio716 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio716 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio717(pub u32);
impl Pio717 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio717Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio717Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio717Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio717Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio717Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio717Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio717Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio717Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio717Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio717Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio717Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio717Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio717 {
    #[inline(always)]
    fn default() -> Pio717 {
        Pio717(0)
    }
}
impl core::fmt::Debug for Pio717 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio717")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio717 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio717 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio718(pub u32);
impl Pio718 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio718Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio718Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio718Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio718Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio718Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio718Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio718Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio718Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio718Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio718Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio718Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio718Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio718 {
    #[inline(always)]
    fn default() -> Pio718 {
        Pio718(0)
    }
}
impl core::fmt::Debug for Pio718 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio718")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio718 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio718 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio719(pub u32);
impl Pio719 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio719Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio719Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio719Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio719Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio719Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio719Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio719Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio719Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio719Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio719Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio719Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio719Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio719 {
    #[inline(always)]
    fn default() -> Pio719 {
        Pio719(0)
    }
}
impl core::fmt::Debug for Pio719 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio719")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio719 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio719 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio72(pub u32);
impl Pio72 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio72Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio72Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio72Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio72Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio72Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio72Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio72Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio72Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio72Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio72Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio72Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio72Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio72 {
    #[inline(always)]
    fn default() -> Pio72 {
        Pio72(0)
    }
}
impl core::fmt::Debug for Pio72 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio72")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio72 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio72 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio720(pub u32);
impl Pio720 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio720Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio720Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio720Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio720Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio720Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio720Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio720Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio720Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio720Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio720Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio720Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio720Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio720 {
    #[inline(always)]
    fn default() -> Pio720 {
        Pio720(0)
    }
}
impl core::fmt::Debug for Pio720 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio720")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio720 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio720 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio721(pub u32);
impl Pio721 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio721Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio721Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio721Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio721Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio721Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio721Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio721Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio721Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio721Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio721Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio721Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio721Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio721 {
    #[inline(always)]
    fn default() -> Pio721 {
        Pio721(0)
    }
}
impl core::fmt::Debug for Pio721 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio721")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio721 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio721 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio722(pub u32);
impl Pio722 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio722Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio722Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio722Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio722Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio722Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio722Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio722Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio722Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio722Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio722Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio722Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio722Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio722 {
    #[inline(always)]
    fn default() -> Pio722 {
        Pio722(0)
    }
}
impl core::fmt::Debug for Pio722 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio722")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio722 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio722 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio723(pub u32);
impl Pio723 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio723Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio723Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio723Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio723Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio723Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio723Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio723Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio723Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio723Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio723Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio723Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio723Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio723 {
    #[inline(always)]
    fn default() -> Pio723 {
        Pio723(0)
    }
}
impl core::fmt::Debug for Pio723 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio723")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio723 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio723 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio724(pub u32);
impl Pio724 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio724Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio724Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio724Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio724Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio724Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio724Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio724Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio724Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio724Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio724Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio724Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio724Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio724 {
    #[inline(always)]
    fn default() -> Pio724 {
        Pio724(0)
    }
}
impl core::fmt::Debug for Pio724 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio724")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio724 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio724 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio725(pub u32);
impl Pio725 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio725Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio725Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio725Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio725Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio725Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio725Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio725Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio725Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio725Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio725Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio725Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio725Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio725 {
    #[inline(always)]
    fn default() -> Pio725 {
        Pio725(0)
    }
}
impl core::fmt::Debug for Pio725 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio725")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio725 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio725 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio726(pub u32);
impl Pio726 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio726Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio726Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio726Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio726Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio726Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio726Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio726Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio726Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio726Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio726Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio726Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio726Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio726 {
    #[inline(always)]
    fn default() -> Pio726 {
        Pio726(0)
    }
}
impl core::fmt::Debug for Pio726 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio726")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio726 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio726 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio727(pub u32);
impl Pio727 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio727Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio727Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio727Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio727Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio727Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio727Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio727Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio727Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio727Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio727Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio727Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio727Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio727 {
    #[inline(always)]
    fn default() -> Pio727 {
        Pio727(0)
    }
}
impl core::fmt::Debug for Pio727 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio727")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio727 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio727 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio728(pub u32);
impl Pio728 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio728Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio728Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio728Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio728Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio728Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio728Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio728Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio728Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio728Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio728Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio728Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio728Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio728 {
    #[inline(always)]
    fn default() -> Pio728 {
        Pio728(0)
    }
}
impl core::fmt::Debug for Pio728 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio728")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio728 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio728 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio729(pub u32);
impl Pio729 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio729Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio729Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio729Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio729Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio729Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio729Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio729Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio729Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio729Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio729Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio729Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio729Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio729 {
    #[inline(always)]
    fn default() -> Pio729 {
        Pio729(0)
    }
}
impl core::fmt::Debug for Pio729 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio729")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio729 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio729 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio73(pub u32);
impl Pio73 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio73Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio73Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio73Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio73Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio73Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio73Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio73Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio73Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio73Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio73Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio73Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio73Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio73 {
    #[inline(always)]
    fn default() -> Pio73 {
        Pio73(0)
    }
}
impl core::fmt::Debug for Pio73 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio73")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio73 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio73 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio730(pub u32);
impl Pio730 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio730Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio730Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio730Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio730Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio730Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio730Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio730Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio730Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio730Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio730Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio730Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio730Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio730 {
    #[inline(always)]
    fn default() -> Pio730 {
        Pio730(0)
    }
}
impl core::fmt::Debug for Pio730 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio730")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio730 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio730 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio731(pub u32);
impl Pio731 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio731Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio731Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio731Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio731Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio731Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio731Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio731Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio731Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio731Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio731Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio731Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio731Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio731 {
    #[inline(always)]
    fn default() -> Pio731 {
        Pio731(0)
    }
}
impl core::fmt::Debug for Pio731 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio731")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio731 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio731 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio74(pub u32);
impl Pio74 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio74Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio74Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio74Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio74Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio74Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio74Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio74Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio74Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio74Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio74Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio74Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio74Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio74 {
    #[inline(always)]
    fn default() -> Pio74 {
        Pio74(0)
    }
}
impl core::fmt::Debug for Pio74 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio74")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio74 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio74 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio75(pub u32);
impl Pio75 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio75Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio75Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio75Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio75Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio75Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio75Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio75Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio75Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio75Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio75Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio75Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio75Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio75 {
    #[inline(always)]
    fn default() -> Pio75 {
        Pio75(0)
    }
}
impl core::fmt::Debug for Pio75 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio75")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio75 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio75 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio76(pub u32);
impl Pio76 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio76Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio76Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio76Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio76Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio76Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio76Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio76Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio76Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio76Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio76Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio76Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio76Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio76 {
    #[inline(always)]
    fn default() -> Pio76 {
        Pio76(0)
    }
}
impl core::fmt::Debug for Pio76 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio76")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio76 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio76 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio77(pub u32);
impl Pio77 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio77Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio77Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio77Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio77Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio77Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio77Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio77Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio77Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio77Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio77Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio77Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio77Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio77 {
    #[inline(always)]
    fn default() -> Pio77 {
        Pio77(0)
    }
}
impl core::fmt::Debug for Pio77 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio77")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio77 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio77 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio78(pub u32);
impl Pio78 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio78Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio78Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio78Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio78Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio78Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio78Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio78Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio78Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio78Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio78Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio78Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio78Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio78 {
    #[inline(always)]
    fn default() -> Pio78 {
        Pio78(0)
    }
}
impl core::fmt::Debug for Pio78 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio78")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio78 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio78 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
#[doc = "iop pad control register for port0 to port5"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pio79(pub u32);
impl Pio79 {
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[must_use]
    #[inline(always)]
    pub const fn fsel(&self) -> super::vals::Pio79Fsel {
        let val = (self.0 >> 0usize) & 0x0f;
        super::vals::Pio79Fsel::from_bits(val as u8)
    }
    #[doc = "Function Selector. . .(FSELs Sources can be found in the next several pages.)"]
    #[inline(always)]
    pub const fn set_fsel(&mut self, val: super::vals::Pio79Fsel) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdena(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Pullup / Pulldown Enable. . ."]
    #[inline(always)]
    pub const fn set_pupdena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn pupdsel(&self) -> super::vals::Pio79Pupdsel {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Pio79Pupdsel::from_bits(val as u8)
    }
    #[doc = "Pullup or Pulldown Selector. . ."]
    #[inline(always)]
    pub const fn set_pupdsel(&mut self, val: super::vals::Pio79Pupdsel) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Input Buffer Enable. ."]
    #[must_use]
    #[inline(always)]
    pub const fn ibena(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "Input Buffer Enable. ."]
    #[inline(always)]
    pub const fn set_ibena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "Slew Rate Control. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn slewrate(&self) -> super::vals::Pio79Slewrate {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Pio79Slewrate::from_bits(val as u8)
    }
    #[doc = "Slew Rate Control. . ."]
    #[inline(always)]
    pub const fn set_slewrate(&mut self, val: super::vals::Pio79Slewrate) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Drive Selector. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn fulldrive(&self) -> super::vals::Pio79Fulldrive {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Pio79Fulldrive::from_bits(val as u8)
    }
    #[doc = "Drive Selector. . ."]
    #[inline(always)]
    pub const fn set_fulldrive(&mut self, val: super::vals::Pio79Fulldrive) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Analog Mux Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn amena(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Analog Mux Enable. . ."]
    #[inline(always)]
    pub const fn set_amena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn odena(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "Pseudo Output Drain Enable. . ."]
    #[inline(always)]
    pub const fn set_odena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "Input Invert Enable. . ."]
    #[must_use]
    #[inline(always)]
    pub const fn iiena(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Input Invert Enable. . ."]
    #[inline(always)]
    pub const fn set_iiena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
}
impl Default for Pio79 {
    #[inline(always)]
    fn default() -> Pio79 {
        Pio79(0)
    }
}
impl core::fmt::Debug for Pio79 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio79")
            .field("fsel", &self.fsel())
            .field("pupdena", &self.pupdena())
            .field("pupdsel", &self.pupdsel())
            .field("ibena", &self.ibena())
            .field("slewrate", &self.slewrate())
            .field("fulldrive", &self.fulldrive())
            .field("amena", &self.amena())
            .field("odena", &self.odena())
            .field("iiena", &self.iiena())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pio79 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pio79 {{ fsel: {:?}, pupdena: {=bool:?}, pupdsel: {:?}, ibena: {=bool:?}, slewrate: {:?}, fulldrive: {:?}, amena: {=bool:?}, odena: {=bool:?}, iiena: {=bool:?} }}",
            self.fsel(),
            self.pupdena(),
            self.pupdsel(),
            self.ibena(),
            self.slewrate(),
            self.fulldrive(),
            self.amena(),
            self.odena(),
            self.iiena()
        )
    }
}
